import aiohttp
import asyncio
import re
from typing import List, Dict
from scanners.base_scanner import BaseScanner
import logging
from datetime import datetime

class VulnerabilityScanner(BaseScanner):
    def __init__(self, target: str):
        super().__init__(target)
        self.test_payloads = {
            'xss': [
                '<script>alert(1)</script>',
                '"><script>alert(1)</script>',
                '"><img src=x onerror=alert(1)>',
                '\'><img src=x onerror=alert(1)>'
            ],
            'sqli': [
                "' OR '1'='1",
                "' UNION SELECT NULL--",
                "admin' --",
                "' OR 1=1--"
            ],
            'command_injection': [
                '| ls',
                '; ls',
                '`ls`',
                '$(ls)'
            ],
            'path_traversal': [
                '../../../etc/passwd',
                '..\\..\\..\\windows\\win.ini',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd'
            ]
        }
        logging.info(f"Initialized VulnerabilityScanner for {target}")
        
    async def _test_endpoint(self, session: aiohttp.ClientSession, url: str, 
                            payload: str, vuln_type: str) -> Dict:
        try:
            # Test GET parameter
            get_url = f"{url}?q={payload}"
            try:
                async with session.get(get_url, timeout=10, ssl=False) as response:
                    content = await response.text()
                    get_result = {
                        'url': get_url,
                        'method': 'GET',
                        'status': response.status,
                        'reflected': payload in content,
                        'error_detected': any(error in content.lower() for error in [
                            'sql', 'mysql', 'postgresql', 'oracle', 'syntax error',
                            'stack trace', 'exception', 'system error', 'undefined',
                            'error', 'failed', 'failure', 'invalid'
                        ])
                    }
            except Exception as e:
                logging.warning(f"GET request failed for {get_url}: {str(e)}")
                get_result = None
            
            # Test POST parameter
            try:
                async with session.post(url, data={'q': payload}, timeout=10, ssl=False) as response:
                    content = await response.text()
                    post_result = {
                        'url': url,
                        'method': 'POST',
                        'status': response.status,
                        'reflected': payload in content,
                        'error_detected': any(error in content.lower() for error in [
                            'sql', 'mysql', 'postgresql', 'oracle', 'syntax error',
                            'stack trace', 'exception', 'system error', 'undefined',
                            'error', 'failed', 'failure', 'invalid'
                        ])
                    }
            except Exception as e:
                logging.warning(f"POST request failed for {url}: {str(e)}")
                post_result = None
            
            if get_result is None and post_result is None:
                return None
            
            return {
                'type': vuln_type,
                'payload': payload,
                'get_test': get_result,
                'post_test': post_result,
                'potentially_vulnerable': (
                    (get_result and (get_result['reflected'] or get_result['error_detected'])) or
                    (post_result and (post_result['reflected'] or post_result['error_detected']))
                ),
                'severity': 'high' if vuln_type in ['sqli', 'command_injection'] else 'medium'
            }
            
        except Exception as e:
            logging.error(f"Error testing endpoint {url}: {str(e)}")
            return None

    async def scan(self) -> dict:
        """Run vulnerability scan"""
        try:
            logging.info(f"Starting vulnerability scan steps for {self.target}")
            
            # Initialize results
            results = {
                "vulnerabilities": [],
                "scan_info": {
                    "start_time": datetime.utcnow().isoformat(),
                    "target": self.target
                }
            }
            
            # Web vulnerability scan
            logging.info("Starting web vulnerability scan...")
            # Try both HTTP and HTTPS
            protocols = ['https', 'http']
            all_findings = []
            
            for protocol in protocols:
                try:
                    logging.info(f"Testing {protocol.upper()} endpoints for {self.target}")
                    base_url = f"{protocol}://{self.target}"
                    test_urls = [base_url, f"{base_url}/search", f"{base_url}/api"]
                    
                    async with aiohttp.ClientSession() as session:
                        tasks = []
                        for url in test_urls:
                            for vuln_type, payloads in self.test_payloads.items():
                                for payload in payloads:
                                    tasks.append(self._test_endpoint(session, url, payload, vuln_type))
                        
                        protocol_findings = [r for r in await asyncio.gather(*tasks) if r is not None and r['potentially_vulnerable']]
                        if protocol_findings:
                            logging.info(f"Found {len(protocol_findings)} potential vulnerabilities over {protocol.upper()}")
                            all_findings.extend(protocol_findings)
                except Exception as e:
                    logging.warning(f"Error scanning {protocol.upper()} endpoints: {str(e)}")
                    continue
            
            # Process and format findings
            processed_findings = []
            for finding in all_findings:
                vuln_info = {
                    "title": f"{finding['type'].upper()} - {finding['payload'][:50]}",
                    "type": finding['type'],
                    "severity": finding['severity'],
                    "description": f"Potential {finding['type']} vulnerability found",
                    "evidence": {
                        "payload": finding['payload'],
                        "endpoints": []
                    }
                }
                
                # Add GET test results if available
                if finding.get('get_test'):
                    vuln_info["evidence"]["endpoints"].append({
                        "url": finding['get_test']['url'],
                        "method": "GET",
                        "status": finding['get_test']['status'],
                        "reflected": finding['get_test']['reflected'],
                        "error_detected": finding['get_test']['error_detected']
                    })
                
                # Add POST test results if available
                if finding.get('post_test'):
                    vuln_info["evidence"]["endpoints"].append({
                        "url": finding['post_test']['url'],
                        "method": "POST",
                        "status": finding['post_test']['status'],
                        "reflected": finding['post_test']['reflected'],
                        "error_detected": finding['post_test']['error_detected']
                    })
                
                processed_findings.append(vuln_info)
            
            # Update results with processed findings
            results["vulnerabilities"] = processed_findings
            results["scan_info"]["end_time"] = datetime.utcnow().isoformat()
            results["scan_info"]["total_vulnerabilities"] = len(processed_findings)
            
            logging.info(f"Vulnerability scan completed for {self.target} with {len(processed_findings)} total vulnerabilities found")
            return results
            
        except Exception as e:
            logging.error(f"Error in vulnerability scan: {str(e)}")
            # Return empty results on error instead of raising
            return {
                "vulnerabilities": [],
                "scan_info": {
                    "start_time": datetime.utcnow().isoformat(),
                    "end_time": datetime.utcnow().isoformat(),
                    "target": self.target,
                    "error": str(e)
                }
            } 