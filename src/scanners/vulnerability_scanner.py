import aiohttp
import asyncio
import re
from typing import List, Dict
from scanners.base_scanner import BaseScanner

class VulnerabilityScanner(BaseScanner):
    def __init__(self, target: str):
        super().__init__(target)
        self.test_payloads = {
            'xss': [
                '<script>alert(1)</script>',
                '"><script>alert(1)</script>',
                '"><img src=x onerror=alert(1)>',
                '\'><img src=x onerror=alert(1)>'
            ],
            'sqli': [
                "' OR '1'='1",
                "' UNION SELECT NULL--",
                "admin' --",
                "' OR 1=1--"
            ],
            'command_injection': [
                '| ls',
                '; ls',
                '`ls`',
                '$(ls)'
            ],
            'path_traversal': [
                '../../../etc/passwd',
                '..\\..\\..\\windows\\win.ini',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd'
            ]
        }
        
    async def _test_endpoint(self, session: aiohttp.ClientSession, url: str, 
                            payload: str, vuln_type: str) -> Dict:
        try:
            # Test GET parameter
            get_url = f"{url}?q={payload}"
            async with session.get(get_url, timeout=5) as response:
                content = await response.text()
                get_result = {
                    'url': get_url,
                    'method': 'GET',
                    'status': response.status,
                    'reflected': payload in content,
                    'error_detected': any(error in content.lower() for error in [
                        'sql', 'mysql', 'postgresql', 'oracle', 'syntax error',
                        'stack trace', 'exception', 'system error'
                    ])
                }
            
            # Test POST parameter
            async with session.post(url, data={'q': payload}, timeout=5) as response:
                content = await response.text()
                post_result = {
                    'url': url,
                    'method': 'POST',
                    'status': response.status,
                    'reflected': payload in content,
                    'error_detected': any(error in content.lower() for error in [
                        'sql', 'mysql', 'postgresql', 'oracle', 'syntax error',
                        'stack trace', 'exception', 'system error'
                    ])
                }
            
            return {
                'type': vuln_type,
                'payload': payload,
                'get_test': get_result,
                'post_test': post_result,
                'potentially_vulnerable': (
                    get_result['reflected'] or 
                    post_result['reflected'] or 
                    get_result['error_detected'] or 
                    post_result['error_detected']
                )
            }
            
        except Exception:
            return None

    async def scan(self) -> dict:
        try:
            base_url = f"https://{self.target}"
            test_urls = [base_url, f"{base_url}/search", f"{base_url}/api"]
            findings = []
            
            async with aiohttp.ClientSession() as session:
                tasks = []
                for url in test_urls:
                    for vuln_type, payloads in self.test_payloads.items():
                        for payload in payloads:
                            tasks.append(self._test_endpoint(session, url, payload, vuln_type))
                
                results = await asyncio.gather(*tasks)
                findings = [r for r in results if r is not None and r['potentially_vulnerable']]
            
            # Analyze findings
            vulnerabilities = {}
            for finding in findings:
                vuln_type = finding['type']
                if vuln_type not in vulnerabilities:
                    vulnerabilities[vuln_type] = []
                vulnerabilities[vuln_type].append(finding)
            
            risk_score = sum(len(vulns) for vulns in vulnerabilities.values())
            
            self.results = {
                'target': self.target,
                'vulnerabilities': vulnerabilities,
                'attack_surface': {
                    'total_vulnerabilities': risk_score,
                    'vulnerability_types': list(vulnerabilities.keys()),
                    'risk_level': 'HIGH' if risk_score > 5 else 'MEDIUM' if risk_score > 0 else 'LOW',
                    'most_vulnerable_endpoints': [
                        url for url in test_urls 
                        if any(f['get_test']['url'].startswith(url) for f in findings)
                    ]
                }
            }
            
        except Exception as e:
            self.results = {
                'error': str(e),
                'target': self.target
            }
            
        return self.results 