import aiohttp
import asyncio
import re
from typing import List, Dict
from scanners.base_scanner import BaseScanner
import logging
from datetime import datetime
from utils.cve_cache import CVECache

class VulnerabilityScanner(BaseScanner):
    def __init__(self, target: str):
        super().__init__(target)
        self.cve_cache = CVECache()
        self.test_payloads = {
            'xss': [
                '<script>alert(1)</script>',
                '"><script>alert(1)</script>',
                '"><img src=x onerror=alert(1)>',
                '\'><img src=x onerror=alert(1)>'
            ],
            'sqli': [
                "' OR '1'='1",
                "' UNION SELECT NULL--",
                "admin' --",
                "' OR 1=1--"
            ],
            'command_injection': [
                '| ls',
                '; ls',
                '`ls`',
                '$(ls)'
            ],
            'path_traversal': [
                '../../../etc/passwd',
                '..\\..\\..\\windows\\win.ini',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd'
            ]
        }
        logging.info(f"Initialized VulnerabilityScanner for {target}")
        
    async def _test_endpoint(self, session: aiohttp.ClientSession, url: str, 
                            payload: str, vuln_type: str) -> Dict:
        try:
            # Test GET parameter
            get_url = f"{url}?q={payload}"
            try:
                async with session.get(get_url, timeout=10, ssl=False) as response:
                    content = await response.text()
                    get_result = {
                        'url': get_url,
                        'method': 'GET',
                        'status': response.status,
                        'reflected': payload in content,
                        'error_detected': any(error in content.lower() for error in [
                            'sql', 'mysql', 'postgresql', 'oracle', 'syntax error',
                            'stack trace', 'exception', 'system error', 'undefined',
                            'error', 'failed', 'failure', 'invalid'
                        ])
                    }
            except Exception as e:
                logging.warning(f"GET request failed for {get_url}: {str(e)}")
                get_result = None
            
            # Test POST parameter
            try:
                async with session.post(url, data={'q': payload}, timeout=10, ssl=False) as response:
                    content = await response.text()
                    post_result = {
                        'url': url,
                        'method': 'POST',
                        'status': response.status,
                        'reflected': payload in content,
                        'error_detected': any(error in content.lower() for error in [
                            'sql', 'mysql', 'postgresql', 'oracle', 'syntax error',
                            'stack trace', 'exception', 'system error', 'undefined',
                            'error', 'failed', 'failure', 'invalid'
                        ])
                    }
            except Exception as e:
                logging.warning(f"POST request failed for {url}: {str(e)}")
                post_result = None
            
            if get_result is None and post_result is None:
                return None
            
            return {
                'type': vuln_type,
                'payload': payload,
                'get_test': get_result,
                'post_test': post_result,
                'potentially_vulnerable': (
                    (get_result and (get_result['reflected'] or get_result['error_detected'])) or
                    (post_result and (post_result['reflected'] or post_result['error_detected']))
                ),
                'severity': 'high' if vuln_type in ['sqli', 'command_injection'] else 'medium'
            }
            
        except Exception as e:
            logging.error(f"Error testing endpoint {url}: {str(e)}")
            return None

    async def _get_relevant_cves(self) -> list:
        """Get relevant CVEs for the target technology stack"""
        try:
            cve_data = await self.cve_cache.get_latest_cves()
            if not cve_data or 'cves' not in cve_data:
                logging.warning("No CVE data available")
                return []

            # Filter CVEs based on technology stack and severity
            relevant_cves = []
            for cve in cve_data['cves']:
                # Check if CVE is recent (last 30 days) and has a high CVSS score
                if cve.get('cvss', 0) >= 7.0:  # High severity threshold
                    relevant_cves.append({
                        'id': cve.get('id'),
                        'description': cve.get('summary'),
                        'cvss': cve.get('cvss'),
                        'references': cve.get('references', []),
                        'published': cve.get('Published')
                    })

            logging.info(f"Found {len(relevant_cves)} relevant CVEs")
            return relevant_cves
        except Exception as e:
            logging.error(f"Error getting relevant CVEs: {str(e)}")
            return []

    async def _generate_cve_tests(self, cves: list) -> dict:
        """Generate test payloads based on CVE data"""
        try:
            new_payloads = {}
            for cve in cves:
                # Use basic pattern matching to identify vulnerability types
                desc = cve.get('description', '').lower()
                if 'sql injection' in desc:
                    if 'sqli' not in new_payloads:
                        new_payloads['sqli'] = []
                    new_payloads['sqli'].extend(self._extract_payloads_from_references(cve))
                elif 'cross-site scripting' in desc or 'xss' in desc:
                    if 'xss' not in new_payloads:
                        new_payloads['xss'] = []
                    new_payloads['xss'].extend(self._extract_payloads_from_references(cve))
                elif 'command injection' in desc:
                    if 'command_injection' not in new_payloads:
                        new_payloads['command_injection'] = []
                    new_payloads['command_injection'].extend(self._extract_payloads_from_references(cve))
                elif 'path traversal' in desc:
                    if 'path_traversal' not in new_payloads:
                        new_payloads['path_traversal'] = []
                    new_payloads['path_traversal'].extend(self._extract_payloads_from_references(cve))

            # Merge with existing payloads
            for vuln_type, payloads in new_payloads.items():
                if vuln_type in self.test_payloads:
                    self.test_payloads[vuln_type].extend(payloads)
                else:
                    self.test_payloads[vuln_type] = payloads

            logging.info(f"Generated {sum(len(p) for p in new_payloads.values())} new test payloads from CVEs")
            return new_payloads
        except Exception as e:
            logging.error(f"Error generating CVE tests: {str(e)}")
            return {}

    def _extract_payloads_from_references(self, cve: dict) -> list:
        """Extract potential test payloads from CVE references"""
        payloads = []
        try:
            # Look for proof of concept URLs or GitHub repositories
            for ref in cve.get('references', []):
                if 'github.com' in ref and '/poc/' in ref.lower():
                    payloads.append(f"CVE:{cve['id']}:POC")  # Placeholder for actual payload
            return payloads
        except Exception as e:
            logging.error(f"Error extracting payloads from CVE {cve.get('id')}: {str(e)}")
            return []

    async def scan(self) -> dict:
        """Run vulnerability scan"""
        try:
            logging.info(f"Starting vulnerability scan steps for {self.target}")
            
            # Get relevant CVEs and generate tests
            relevant_cves = await self._get_relevant_cves()
            if relevant_cves:
                await self._generate_cve_tests(relevant_cves)
            
            # Initialize results
            results = {
                "vulnerabilities": [],
                "scan_info": {
                    "start_time": datetime.utcnow().isoformat(),
                    "target": self.target,
                    "cve_data": {
                        "total_cves_checked": len(relevant_cves),   
                        "high_severity_cves": len([cve for cve in relevant_cves if cve.get('cvss', 0) >= 7.0])
                    }
                }
            }
            
            # Web vulnerability scan
            logging.info("Starting web vulnerability scan...")
            # Try both HTTP and HTTPS
            protocols = ['https', 'http']
            all_findings = []
            
            for protocol in protocols:
                try:
                    logging.info(f"Testing {protocol.upper()} endpoints for {self.target}")
                    base_url = f"{protocol}://{self.target}"
                    test_urls = [base_url, f"{base_url}/search", f"{base_url}/api"]
                    
                    async with aiohttp.ClientSession() as session:
                        tasks = []
                        for url in test_urls:
                            for vuln_type, payloads in self.test_payloads.items():
                                for payload in payloads:
                                    tasks.append(self._test_endpoint(session, url, payload, vuln_type))
                        
                        protocol_findings = [r for r in await asyncio.gather(*tasks) if r is not None and r['potentially_vulnerable']]
                        if protocol_findings:
                            logging.info(f"Found {len(protocol_findings)} potential vulnerabilities over {protocol.upper()}")
                            all_findings.extend(protocol_findings)
                except Exception as e:
                    logging.warning(f"Error scanning {protocol.upper()} endpoints: {str(e)}")
                    continue
            
            # Process and format findings
            processed_findings = []
            for finding in all_findings:
                vuln_info = {
                    "title": f"{finding['type'].upper()} - {finding['payload'][:50]}",
                    "type": finding['type'],
                    "severity": finding['severity'],
                    "description": f"Potential {finding['type']} vulnerability found",
                    "evidence": {
                        "payload": finding['payload'],
                        "endpoints": []
                    }
                }
                
                # Add GET test results if available
                if finding.get('get_test'):
                    vuln_info["evidence"]["endpoints"].append({
                        "url": finding['get_test']['url'],
                        "method": "GET",
                        "status": finding['get_test']['status'],
                        "reflected": finding['get_test']['reflected'],
                        "error_detected": finding['get_test']['error_detected']
                    })
                
                # Add POST test results if available
                if finding.get('post_test'):
                    vuln_info["evidence"]["endpoints"].append({
                        "url": finding['post_test']['url'],
                        "method": "POST",
                        "status": finding['post_test']['status'],
                        "reflected": finding['post_test']['reflected'],
                        "error_detected": finding['post_test']['error_detected']
                    })
                
                processed_findings.append(vuln_info)
            
            # Update results with processed findings
            results["vulnerabilities"] = processed_findings
            results["scan_info"]["end_time"] = datetime.utcnow().isoformat()
            results["scan_info"]["total_vulnerabilities"] = len(processed_findings)
            
            logging.info(f"Vulnerability scan completed for {self.target} with {len(processed_findings)} total vulnerabilities found")
            return results
            
        except Exception as e:
            logging.error(f"Error in vulnerability scan: {str(e)}")
            # Return empty results on error instead of raising
            return {
                "vulnerabilities": [],
                "scan_info": {
                    "start_time": datetime.utcnow().isoformat(),
                    "end_time": datetime.utcnow().isoformat(),
                    "target": self.target,
                    "error": str(e)
                }
            } 